const express = require("express");
const app = express();
const cors = require("cors");
const dotenv = require("dotenv");
const path = require("path");

dotenv.config({ path: path.join(__dirname, "config", "config.env") });

app.use(express.json());
app.use(cors());
// app.use(
//   cors({
//     origin: ["https://ecommerce-v1-xvv0.onrender.com"], // your deployed frontend URL
//     methods: ["GET", "POST", "PUT", "DELETE"],
//     credentials: true,
//   })
// );

const { MongoClient, ServerApiVersion, ObjectId } = require("mongodb");
const { count } = require("console");
const uri =
  "mongodb+srv://mithunpriyan157official_db_user:Mp%40157157@cluster0.d46wy7s.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0";

// Create a MongoClient with a MongoClientOptions object to set the Stable API version
const client = new MongoClient(uri, {
  serverApi: {
    version: ServerApiVersion.v1,
    strict: true,
    deprecationErrors: true,
  },
});

async function run() {
  try {
    const db = client.db("ecommerce-v1");
    const eCommerce = db.collection("SmartBuyz");
    const eCommerceCart = db.collection("orderedItems");

    app.get("/products", async (req, res) => {
      try {
        const products = await eCommerce.find();
        const productList = await products.toArray();
        return res.status(200).json(productList);
      } catch (error) {
        return res.status(500).json({
          success: false,
          message: "Error fetching products",
          error: error.message,
        });
      }
    });

    app.get("/product/:id", async (req, res) => {
      try {
        const id = req.params.id;
        const objectId = { _id: new ObjectId(id) };
        const products = await eCommerce.findOne(objectId);
        res.status(200).json(products);
      } catch (error) {
        res.status(500).json({
          success: false,
          message: "Error fetching products",
          error: error.message,
        });
      }
    });

    app.post("/addcart", async (req, res) => {
      try {
        const cartItem = req.body.orderedItems || req.body;

        for (const item of cartItem) {
          const productId = new ObjectId(item.products._id);
          const quantity = item.qty;

          const product = await eCommerce.findOne({ _id: productId });
          console.log("ðŸ›’ Received Cart Items:", product);

          if (!product) {
            return res
              .status(404)
              .json({ success: false, message: "Product not found" });
          }

          if (product.stock < quantity) {
            return res.status(400).json({
              success: false,
              message: `Not enough stock for ${product.name}`,
            });
          }
          await eCommerce.updateOne(
            { _id: productId },
            { $inc: { stock: -quantity } }
          );
          console.log(`Stock updated for ${product.name}: -${quantity}`);
        }
        const addItem = await eCommerceCart.insertMany(cartItem);
        console.log(addItem);
        res.status(200).json({
          success: true,
          message: "Order placed successfully & stock updated",
          data: addItem,
        });
      } catch (error) {
        res.status(500).json({
          success: false,
          message: "Error placing order",
          error: error.message,
        });
      }
    });

    app.get("/orderedItems", async (req, res) => {
      try {
        const orders = await eCommerceCart.find();
        const ordersList = await orders.toArray();
        return res.status(200).json(ordersList);
      } catch (error) {
        res.status(500).json({
          success: false,
          message: "Error fetching products",
          error: error.message,
        });
      }
    });

    app.delete("/cancelOrder/:id", async (req, res) => {
      try {
        const id = req.params.id;
        const objectId = new ObjectId(id);

        const cancelledOrder = await eCommerceCart.findOne({ _id: objectId });

        if (cancelledOrder.deletedCount === 0) {
          return res.status(404).json({
            success: false,
            message: "Order not found or already deleted",
          });
        }
        const productId = new ObjectId(cancelledOrder.products._id);
        const qtyToRestore = cancelledOrder.qty;
        console.log(qtyToRestore);

        await eCommerce.updateOne(
          { _id: productId },
          { $inc: { stock: +qtyToRestore } }
        );
        console.log(
          `Stock restored for ${cancelledOrder.products.name}: +${qtyToRestore}`
        );

        await eCommerceCart.deleteOne({ _id: objectId });
        res.status(200).json({
          success: true,
          message: "Order cancelled successfully & Stock restored",
        });
      } catch (error) {
        console.error(" Error cancelling order:", error.message);
        res.status(500).json({
          success: false,
          message: "Error cancelling order",
          error: error.message,
        });
      }
    });
    // Connect the client to the server	(optional starting in v4.7)
    await client.connect();
    // Send a ping to confirm a successful connection
    await client.db("admin").command({ ping: 1 });
    console.log(
      "Pinged your deployment. You successfully connected to MongoDB!"
    );
  } finally {
    // Ensures that the client will close when you finish/error
    // await client.close();
  }
}
run().catch(console.dir);

app.listen(process.env.PORT, () => {
  console.log(
    `Server listening to Port ${process.env.PORT} in ${process.env.NODE_ENV}`
  );
});
